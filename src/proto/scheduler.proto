syntax = "proto3";

package mini_borg;

// Data structures
message Resource {
    int32 cpu_cores = 1;
    uint64 memory_mb = 2;
}

enum JobStatus {
    JOB_STATUS_UNKNOWN = 0;
    JOB_STATUS_QUEUED = 1;
    JOB_STATUS_RUNNING = 2;
    JOB_STATUS_COMPLETED = 3;
    JOB_STATUS_FAILED = 4;
    JOB_STATUS_CANCELLED = 5;  // TODO: Implement logic to check if job cancelled
}

message Job {
    string id = 1;
    string name = 2;
    Resource resource_reqs = 3;
    JobStatus status = 4;
    string worker_id = 5;
}

// Request/Response wrappers
// INPUT: user wants to run a job
message SubmitJobRequest {
    string name = 1;
    Resource resource_reqs = 2;
}

// OUTPUT: master says job has been queued
message SubmitJobResponse {
    string job_id = 1;  // return id for user to track
}

message FinishJobRequest {
    string job_id = 1;
    string worker_id = 2;
    bool success = 3;
    Resource released_resources = 4;
}

message FinishJobResponse {}

// worker says "im still alive!""
message HeartbeatRequest {
    string worker_id = 1;
    Resource available_resources = 2;
    repeated string running_job_ids = 3;
}

// master acknowledges worker alive and sends orders
message HeartbeatResponse {
    string ack = 1;
    repeated Job jobs_to_start = 2;
    repeated Job job_ids_to_kill = 3;
}

// Services
service Coordinator {
    // User -> Master
    rpc SubmitJob(SubmitJobRequest) returns (SubmitJobResponse);
    // Worker -> Master
    rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
    // Worker sends release resources in order to not query the db, lowering latency
    rpc FinishJob(FinishJobRequest) returns (FinishJobResponse);
}
